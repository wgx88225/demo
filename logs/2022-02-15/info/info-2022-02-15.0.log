2022-02-15 09:23:36.072 [main] INFO  traceId[] com.example.demo.DemoApplication:55 - Starting DemoApplication on DESKTOP-6OUD5PV with PID 18280 (E:\workplace\idea\demo\target\classes started by Administrator in E:\workplace\idea\demo)
2022-02-15 09:23:36.090 [main] INFO  traceId[] com.example.demo.DemoApplication:651 - No active profile set, falling back to default profiles: default
2022-02-15 09:23:37.523 [main] INFO  traceId[] o.s.d.r.config.RepositoryConfigurationDelegate:249 - Multiple Spring Data modules found, entering strict repository configuration mode!
2022-02-15 09:23:37.525 [main] INFO  traceId[] o.s.d.r.config.RepositoryConfigurationDelegate:127 - Bootstrapping Spring Data Redis repositories in DEFAULT mode.
2022-02-15 09:23:37.580 [main] INFO  traceId[] o.s.d.r.config.RepositoryConfigurationDelegate:187 - Finished Spring Data repository scanning in 43ms. Found 0 Redis repository interfaces.
2022-02-15 09:23:37.827 [main] INFO  traceId[] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker:335 - Bean 'threadPoolConfig' of type [com.example.demo.config.ThreadPoolConfig$$EnhancerBySpringCGLIB$$825d9260] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2022-02-15 09:23:37.844 [main] INFO  traceId[] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker:335 - Bean 'org.springframework.retry.annotation.RetryConfiguration' of type [org.springframework.retry.annotation.RetryConfiguration$$EnhancerBySpringCGLIB$$4e7a3126] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2022-02-15 09:23:38.247 [main] INFO  traceId[] io.undertow.servlet:364 - Initializing Spring embedded WebApplicationContext
2022-02-15 09:23:38.247 [main] INFO  traceId[] o.s.b.w.s.c.ServletWebServerApplicationContext:285 - Root WebApplicationContext: initialization completed in 2090 ms
2022-02-15 09:23:38.368 [main] INFO  traceId[] c.example.demo.config.ThreadPoolExecutorMdcWrapper:181 - Initializing ExecutorService 'threadPoolTaskExecutor'
2022-02-15 09:23:38.593 [main] INFO  traceId[] c.a.d.s.b.a.DruidDataSourceAutoConfigure:56 - Init DruidDataSource
2022-02-15 09:23:39.964 [main] INFO  traceId[] com.alibaba.druid.pool.DruidDataSource:990 - {dataSource-1} inited
2022-02-15 09:23:42.225 [main] INFO  traceId[] o.s.scheduling.concurrent.ThreadPoolTaskScheduler:181 - Initializing ExecutorService 'taskScheduler'
2022-02-15 09:23:42.279 [main] INFO  traceId[] io.undertow:117 - starting server: Undertow - 2.1.3.Final
2022-02-15 09:23:42.294 [main] INFO  traceId[] org.xnio:95 - XNIO version 3.8.0.Final
2022-02-15 09:23:42.305 [main] INFO  traceId[] org.xnio.nio:59 - XNIO NIO Implementation Version 3.8.0.Final
2022-02-15 09:23:42.334 [main] INFO  traceId[] org.jboss.threads:52 - JBoss Threads version 3.1.0.Final
2022-02-15 09:23:42.390 [main] INFO  traceId[] o.s.boot.web.embedded.undertow.UndertowWebServer:133 - Undertow started on port(s) 9090 (http)
2022-02-15 09:23:42.399 [main] INFO  traceId[] com.example.demo.DemoApplication:61 - Started DemoApplication in 7.141 seconds (JVM running for 8.854)
2022-02-15 09:30:25.589 [XNIO-1 task-1] INFO  traceId[] io.undertow.servlet:364 - Initializing Spring DispatcherServlet 'dispatcherServlet'
2022-02-15 09:30:25.590 [XNIO-1 task-1] INFO  traceId[] org.springframework.web.servlet.DispatcherServlet:525 - Initializing Servlet 'dispatcherServlet'
2022-02-15 09:30:25.596 [XNIO-1 task-1] INFO  traceId[] org.springframework.web.servlet.DispatcherServlet:547 - Completed initialization in 6 ms
2022-02-15 09:30:25.796 [XNIO-1 task-1] INFO  traceId[da334445-4cc7-4c10-bdbe-d6d536257978] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"实现级","serialNumber":1},{"correct":false,"option":"结构级","serialNumber":2},{"correct":false,"option":"功能级","serialNumber":3},{"correct":false,"option":"领域级","serialNumber":4}],"queSetId":2,"remark":"【2013 年题 21 解析】逆向工程导出的信息可分为如下 4 个抽象层次。实现级：包括程序的抽象语法树、符号表等信息。结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图等。功能级：包括反映程序段功能及程序段之间关系的信息。领域级：包括反映程序分量或程序与应用领域概念之间对应关系的信息。 【答案】A。","topicDesc":"【2013 年题 21】逆向工程导出的信息可以分为实现级、结构级、功能级和领域级四个抽象层次。程序的抽象语法树属于( )；","topicType":1,"updateB":"0"}
2022-02-15 09:30:26.015 [XNIO-1 task-1] INFO  traceId[da334445-4cc7-4c10-bdbe-d6d536257978] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:31:02.117 [XNIO-1 task-1] INFO  traceId[f86640c4-a785-4fc8-bfb0-6d5d20db7bc3] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"实现级","serialNumber":1},{"correct":false,"option":"结构级","serialNumber":2},{"correct":false,"option":"功能级","serialNumber":3},{"correct":true,"option":"领域级","serialNumber":4}],"queSetId":2,"remark":"【2013 年题 21 解析】逆向工程导出的信息可分为如下 4 个抽象层次。实现级：包括程序的抽象语法树、符号表等信息。结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图等。功能级：包括反映程序段功能及程序段之间关系的信息。领域级：包括反映程序分量或程序与应用领域概念之间对应关系的信息。 【答案】D。","topicDesc":"【2013 年题 21】逆向工程导出的信息可以分为实现级、结构级、功能级和领域级四个抽象层次。反映程序分量之间相互依赖关系的信息属于( )；","topicType":1,"updateB":"0"}
2022-02-15 09:31:02.125 [XNIO-1 task-1] INFO  traceId[f86640c4-a785-4fc8-bfb0-6d5d20db7bc3] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:33:13.704 [XNIO-1 task-1] INFO  traceId[8132d698-d310-4689-a503-e3d86b12a8fb] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"逆向工程((Reverse Engineering)","serialNumber":1},{"correct":false,"option":"系统改进 (System Improvement)","serialNumber":2},{"correct":false,"option":"设计恢复 (DesignRecovery )","serialNumber":3},{"correct":false,"option":"再工程 (Re-engineering)","serialNumber":4}],"queSetId":2,"remark":"所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。与之相关的概念是：重构（restructuring），指在同一抽象级别上转换系统描述形式；设计恢复（design recovery)，指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；再工程（re-engineering），也称修复和改造工程，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。 【答案】A","topicDesc":"【2017 年题 29】应用系统构建中可以采用多种不同的技术，( )可以将软件某种形式的描述转换为更高级的抽象表现形式","topicType":1,"updateB":"0"}
2022-02-15 09:33:13.727 [XNIO-1 task-1] INFO  traceId[8132d698-d310-4689-a503-e3d86b12a8fb] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:34:03.341 [XNIO-1 task-1] INFO  traceId[7aa04321-219e-4d09-9e5e-d759d27a1b3b] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"逆向工程((Reverse Engineering)","serialNumber":1},{"correct":false,"option":"系统改进 (System Improvement)","serialNumber":2},{"correct":false,"option":"设计恢复 (DesignRecovery )","serialNumber":3},{"correct":true,"option":"再工程 (Re-engineering)","serialNumber":4}],"queSetId":2,"remark":"所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。与之相关的概念是：重构（restructuring），指在同一抽象级别上转换系统描述形式；设计恢复（design recovery)，指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；再工程（re-engineering），也称修复和改造工程，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。 【答案】D","topicDesc":"【2017 年题 29】应用系统构建中可以采用多种不同的技术，可以将软件某种形式的描述转换为更高级的抽象表现形式，而利用这些获取的信息，( )能够对现有系统进行修改或重构，从而产生系统的一个新版本。","topicType":1,"updateB":"0"}
2022-02-15 09:34:03.349 [XNIO-1 task-1] INFO  traceId[7aa04321-219e-4d09-9e5e-d759d27a1b3b] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:36:22.971 [XNIO-1 task-1] INFO  traceId[30cb17e4-ce40-43ee-9847-0d2f406c6cfb] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"外部设计","serialNumber":1},{"correct":false,"option":"内部设计","serialNumber":2},{"correct":false,"option":"程序设计","serialNumber":3},{"correct":false,"option":"输入/输出设计","serialNumber":4}],"queSetId":2,"remark":"【2011 年题 29 解析】在软件开发中，外部设计又称为概要设计，其主要职能是设计各个部分的功能、接口、相互如何关联。内部设计又称为详细设计，其主要职能是设计具体一个模块的实现。所以本题应选 A。","topicDesc":"【2011 年题 29】系统设计是软件开发的重要阶段，( )主要是按系统需求说明来确定此系统的软件结构，并设计出各个部分的功能和接口。","topicType":1,"updateB":"0"}
2022-02-15 09:36:22.994 [XNIO-1 task-1] INFO  traceId[30cb17e4-ce40-43ee-9847-0d2f406c6cfb] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:38:38.201 [XNIO-1 task-1] INFO  traceId[7dfc9a5a-db80-4c6c-9cb9-a4830f681c9c] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"可视化原型开发","serialNumber":1},{"correct":false,"option":"抛弃式原型开发","serialNumber":2},{"correct":true,"option":"演化式原型开发","serialNumber":3},{"correct":false,"option":"增量式原型开发","serialNumber":4}],"queSetId":2,"remark":"【2011 年题 30 解析】原型开发分两大类：快速原型法(又称抛弃式原型法 )和演化式原型法。其中快速原型法是快速开发出一个原型，利用该原型获取用户需求，然后将该原型抛弃。而演化式原型法是将原型逐步进化为最终的目标系统。所以本题应选 C。","topicDesc":"【2011 年题 30】快速迭代式的原型开发能够有效控制成本，( )是指在开发过程中逐步改进和细化原型直至产生出目标系统。","topicType":1,"updateB":"0"}
2022-02-15 09:38:38.226 [XNIO-1 task-1] INFO  traceId[7dfc9a5a-db80-4c6c-9cb9-a4830f681c9c] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:41:42.958 [XNIO-1 task-1] INFO  traceId[85de4945-678c-4149-b138-cb857764f9b4] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"在瀑布模型中，前一个阶段的错误和疏漏会隐蔽地带到后一个阶段","serialNumber":1},{"correct":false,"option":"在任何情况下使用演化模型，都能在一定周期内由原型演化到最终产品","serialNumber":2},{"correct":false,"option":"软件生存周期模型的主要目标是为了加快软件开发的速度","serialNumber":3},{"correct":false,"option":"当一个软件系统的生存周期结束之后，它就进入到一个新的生存周期模型","serialNumber":4}],"queSetId":2,"remark":"【2012 年题 26 解析】【答案】A。","topicDesc":"【2012 年题 26】以下关于软件生存周期模型的叙述，正确的是( )。","topicType":1,"updateB":"0"}
2022-02-15 09:41:42.980 [XNIO-1 task-1] INFO  traceId[85de4945-678c-4149-b138-cb857764f9b4] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:44:33.324 [XNIO-1 task-1] INFO  traceId[018dcab6-f9f2-4e96-ae9f-ef5182327d3e] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"瀑布模型","serialNumber":1},{"correct":false,"option":"原型模式","serialNumber":2},{"correct":false,"option":"螺旋模型","serialNumber":3},{"correct":false,"option":"基于构建的模型","serialNumber":4}],"queSetId":2,"remark":"瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建筑在前一个阶段正确结果之上，前一个阶段的错漏会隐蔽地带到后一个阶段。这种错误有时甚至可能是灾难性的。因此每一个阶段工作完成后，都要进行审查和确认，这是非常重要的。历史上，瀑布模型起到了重要作用，它的出现有利于人员的组织管理，有利于软件开发方法和工具的研究。 【答案】A。","topicDesc":"【2017 年题 20】软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，软件过程模型是软件开发实际过程的抽象与概括，它应该包括构成软件过程的各种活动。软件过程有各种各样的模型，其中，( )的活动之间存在因果关系，前一阶段工作的结果是后一段阶段工作的输入描述。","topicType":1,"updateB":"0"}
2022-02-15 09:44:33.347 [XNIO-1 task-1] INFO  traceId[018dcab6-f9f2-4e96-ae9f-ef5182327d3e] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:46:53.154 [XNIO-1 task-1] INFO  traceId[411e1f50-6a86-408a-a0ed-1540885b1fd8] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"原型模型","serialNumber":1},{"correct":false,"option":"瀑布模型","serialNumber":2},{"correct":false,"option":"螺旋模型","serialNumber":3},{"correct":false,"option":"基于构件的模型","serialNumber":4}],"queSetId":2,"remark":"【2018 年题 20 解析】答案 A。","topicDesc":"【2018 年题 20】软件开发过程模型中，（ ）主要由原型开发阶段和目标软件开发阶段构成。","topicType":1,"updateB":"0"}
2022-02-15 09:46:53.177 [XNIO-1 task-1] INFO  traceId[411e1f50-6a86-408a-a0ed-1540885b1fd8] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:49:40.098 [XNIO-1 task-1] INFO  traceId[ac1b87a4-308a-4ff6-907e-9bf412e88fc5] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"构件","serialNumber":1},{"correct":false,"option":"模型","serialNumber":2},{"correct":false,"option":"协议","serialNumber":3},{"correct":false,"option":"连接子","serialNumber":4}],"queSetId":2,"remark":"【2014 年题 30 解析】检测并消除体系结构失配：体系结构失配问题由 David Garlan 等人在 1995 年提出。失配是指在软件复用的过程中，由于待复用构件对最终系统的体系结构和环境的假设(assumption)与实际状况不同而导致的冲突。在构件组装阶段失配问题主要包括： (1)由构件引起的失配，包括由于系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突引起的失配； (2)由连接子引起的失配，包括由于系统对构件交互协议、连接子数据模型的假设存在冲突引起的失配； (3)由于系统成分对全局体系结构的假设存在冲突引起的失配等。要解决失配问题，首先需要检测出失配问题，并在此基础上通过适当的手段消除检测出的失配问题。答案 A。","topicDesc":"【2014 年题 30】在构件组装过程中需要检测并解决架构失配问题。其中( )失配主要包括由于系统对构件基础设施、控制模型和数据模型的假设存在冲突引起的失配。","topicType":1,"updateB":"0"}
2022-02-15 09:49:40.121 [XNIO-1 task-1] INFO  traceId[ac1b87a4-308a-4ff6-907e-9bf412e88fc5] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:50:15.354 [XNIO-1 task-1] INFO  traceId[60dea820-533f-4139-b1b1-06f0952f7c39] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"构件","serialNumber":1},{"correct":false,"option":"模型","serialNumber":2},{"correct":false,"option":"协议","serialNumber":3},{"correct":true,"option":"连接子","serialNumber":4}],"queSetId":2,"remark":"【2014 年题 30 解析】检测并消除体系结构失配：体系结构失配问题由 David Garlan 等人在 1995 年提出。失配是指在软件复用的过程中，由于待复用构件对最终系统的体系结构和环境的假设(assumption)与实际状况不同而导致的冲突。在构件组装阶段失配问题主要包括： (1)由构件引起的失配，包括由于系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突引起的失配； (2)由连接子引起的失配，包括由于系统对构件交互协议、连接子数据模型的假设存在冲突引起的失配； (3)由于系统成分对全局体系结构的假设存在冲突引起的失配等。要解决失配问题，首先需要检测出失配问题，并在此基础上通过适当的手段消除检测出的失配问题。答案 D。","topicDesc":"【2014 年题 30】在构件组装过程中需要检测并解决架构失配问题。其中( )失配包括由手系统对构件交互协议、构件连接时数据格式的假设存在冲突引起的失配。","topicType":1,"updateB":"0"}
2022-02-15 09:50:15.361 [XNIO-1 task-1] INFO  traceId[60dea820-533f-4139-b1b1-06f0952f7c39] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:53:17.964 [XNIO-1 task-1] INFO  traceId[85cd2010-63f2-4dad-bdc5-4edfd6665d5a] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"在软件开发的早期就可以对关键的，影响大的风险进行处理","serialNumber":1},{"correct":false,"option":"可以避免需求的变更","serialNumber":2},{"correct":false,"option":"能够非常快速地实现系统的所有需求","serialNumber":3},{"correct":false,"option":"能够更好地控制软件的质量","serialNumber":4}],"queSetId":2,"remark":"【2015 年题 25 解析】RUP（统一软件开发过程，Rational Unified Process），RUP 的三个核心特点是：以架构为中心，用例驱动，增量与迭代。其中增量与迭代的好处是：降低了在一个增量上的开支风险。如果开发人员重复某个迭代，那么损失只是这一个开发有误的迭代的花费。降低了产品无法按照既定进度进入市场的风险。通过在开发早期就确定风险，可以尽早来解决而不至于在开发后期匆匆忙忙。加快了整个开发工作的进度。因为开发人员清楚问题的焦点所在，他们的工作会更有效率。由于用户的需求并不能在一开始就作出完全的界定，它们通常是在后续阶段中不断细化的。因此，迭代过程这种模式使适应需求的变化会更容易些。 【答案】：A。","topicDesc":"【2015 年题 25】RUP 强调采用（迭代和增量）的方式来开发软件，这样做的好处是（）。","topicType":1,"updateB":"0"}
2022-02-15 09:53:17.985 [XNIO-1 task-1] INFO  traceId[85cd2010-63f2-4dad-bdc5-4edfd6665d5a] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:55:51.266 [XNIO-1 task-1] INFO  traceId[5c484588-21ec-4ae1-8165-3f69e0c36fdb] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"对象","serialNumber":1},{"correct":false,"option":"构件","serialNumber":2},{"correct":true,"option":"标准函数库","serialNumber":3},{"correct":false,"option":"设计模式","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 27 解析】软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。按照重用活动是否跨越相似性较少的多个应用领域，软件重用可以区别为横向重用和纵向重用。横向重用是指重用不同应用领域中的软件元素，例如数据结构、分类算法和人机界面构建等。标准函数是一种典型的、原始的横向重用机制。纵向重用是指在一类具有较多公共性的应用领域之间进行软部件重用。纵向重用活动的主要关键点是域分析：根据应用领域的特征及相似性预测软部件的可重用性。 【答案】C。","topicDesc":"【2010 年题 27】软件的横向重用是指重用不同应用领域中的软件元素。( )是一种典型的、原始的横向重用机制。","topicType":1,"updateB":"0"}
2022-02-15 09:55:51.299 [XNIO-1 task-1] INFO  traceId[5c484588-21ec-4ae1-8165-3f69e0c36fdb] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 09:58:28.105 [XNIO-1 task-1] INFO  traceId[e9869bff-0014-46f5-8cff-58417f7a7d55] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"是一个实例单元，具有唯一的标志","serialNumber":1},{"correct":false,"option":"可以利用容器管理自身对外的可见状态","serialNumber":2},{"correct":true,"option":"利用工厂方法(如构造函数)来创建自己的实例","serialNumber":3},{"correct":false,"option":"之间可以共享一个类元素","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 26 解析】构件的特性是: （1）独立部署单元； （2）作为第三方的组装单元； （3）没有（外部的）可见状态。一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。将一个类拆分进行部署通常没什么意义。对象的特性是： （1）一个实例单元，具有唯一的标志。 （2）可能具有状态，此状态外部可见。 （3）封装了自己的状态和行为。 【答案】C。","topicDesc":"【2017 年题 26】软件构件是一个独立可部署的软件单元，与程序设计中的对象不同，构件( )。","topicType":1,"updateB":"0"}
2022-02-15 09:58:28.126 [XNIO-1 task-1] INFO  traceId[e9869bff-0014-46f5-8cff-58417f7a7d55] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:01:05.660 [XNIO-1 task-1] INFO  traceId[1cd18452-bdb0-4749-8314-fe92e289f9fc] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"使用 ABSD 方法，设计活动可以从项目总体功能框架明确就开始","serialNumber":1},{"correct":false,"option":"ABSD 方法是一个自顶向下，递归细化的过程","serialNumber":2},{"correct":false,"option":"ABSD 方法有三个基础：功能分解、选择架构风格实现质量和商业需求以及软件模板的使用","serialNumber":3},{"correct":true,"option":"使用 ABSD 方法，设计活动的开始意味着需求抽取和分析活动可以终止","serialNumber":4}],"queSetId":2,"remark":"【2009 年题 38 解析】基于架构的软件设计（ABSD）强调由商业、质量和功能需求的组合驱动软件架构设计。使用 ABSD 方法，设计活动可以从项目总体功能框架明确就开始，并且设计活动的开始并不意味着需求抽取和分析活动可以终止，而是应该与设计活动并行。ABSD 方法有三个基础：第一个基础是功能分解，在功能分解中使用已有的基于模块的内聚和耦合技术。第二个基础是通过选择体系结构风格来实现质量和商业需求。第三个基础是软件模板的使用。ABSD 方法是一个自顶向下，递归细化的过程，软件系统的架构通过该方法得到细化，直到能产生软件构件的类。 【答案】D。","topicDesc":"【2009 年题 38】基于架构的软件设计(ABSD)强调由商业、质量和功能需求的组合驱动软件架构设计。以下关于 ABSD 的叙述中，错误的是( ) 。","topicType":1,"updateB":"0"}
2022-02-15 10:01:05.682 [XNIO-1 task-1] INFO  traceId[1cd18452-bdb0-4749-8314-fe92e289f9fc] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:03:38.853 [XNIO-1 task-1] INFO  traceId[a3741840-ca09-491d-94cc-0c64efb9be30] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"类图和序列图","serialNumber":1},{"correct":true,"option":"视角与视图","serialNumber":2},{"correct":false,"option":"构件和类图","serialNumber":3},{"correct":false,"option":"构件与功能","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 39 解析】根据定义，基于软件架构的开发(Architecture Based Software Development，ABSD )强调由商业、质量和功能需求的组合驱动软件架构设计。它强调采用视角和视图来描述软件架构，采用用例和质量属性场景来描述需求。 【答案】：B。","topicDesc":"【2010 年题 39】基 于 软 件 架 构 的 设 计 ( Architecture Based Software Development，ABSD)强调由商业、质量和功能需求的组合驱动软件架构设计。它强调采用( )来描述软件架构","topicType":1,"updateB":"0"}
2022-02-15 10:03:38.877 [XNIO-1 task-1] INFO  traceId[a3741840-ca09-491d-94cc-0c64efb9be30] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:04:43.339 [XNIO-1 task-1] INFO  traceId[a7b71270-cfdb-4b1a-ba48-02362d46d2b6] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"用例与类图","serialNumber":1},{"correct":false,"option":"用例与视角","serialNumber":2},{"correct":true,"option":"用例与质量场景","serialNumber":3},{"correct":false,"option":"视角与质量场景","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 39 解析】根据定义，基于软件架构的开发(Architecture Based Software Development，ABSD )强调由商业、质量和功能需求的组合驱动软件架构设计。它强调采用视角和视图来描述软件架构，采用用例和质量属性场景来描述需求。 【答案】：C。","topicDesc":"【2010 年题 39】基于软件架构的设计 ( Architecture Based Software Development，ABSD)强调由商业、质量和功能需求的组合驱动软件架构设计。它强调采用( )来描述需求","topicType":1,"updateB":"0"}
2022-02-15 10:04:43.359 [XNIO-1 task-1] INFO  traceId[a7b71270-cfdb-4b1a-ba48-02362d46d2b6] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:11:22.665 [XNIO-1 task-1] INFO  traceId[98d6b8dc-f6b0-4f62-be1a-00013902ffee] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"逻辑构件模型","serialNumber":1},{"correct":false,"option":"物理构件模型","serialNumber":2},{"correct":false,"option":"组件接口模型","serialNumber":3},{"correct":false,"option":"系统交互模型","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 31 解析】在基于构件的软件开发中，逻辑构件模型用功能包描述系统的抽象设计，用接口描述每个服务集合，以及功能之间如何交互以满足用户需求，它作为系统的设计蓝图以保证系统提供适当的功能。物理构件模型用技术设施产品、硬件分布和拓扑结构、以及用于绑定的网络和通信协议描述系统的物理设计，这种架构用于了解系统的性能、吞吐率等许多非功能性属性。 【答案】：A。","topicDesc":"【2010 年题 31】在基于构件的软件开发中，( )描述系统设计蓝图以保证系统提供适当的功能； ","topicType":1,"updateB":"0"}
2022-02-15 10:11:22.687 [XNIO-1 task-1] INFO  traceId[98d6b8dc-f6b0-4f62-be1a-00013902ffee] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:11:42.384 [XNIO-1 task-1] INFO  traceId[23382f73-ef23-4504-bdce-f93f8edd6877] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"逻辑构件模型","serialNumber":1},{"correct":false,"option":"物理构件模型","serialNumber":2},{"correct":false,"option":"组件接口模型","serialNumber":3},{"correct":false,"option":"系统交互模型","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 31 解析】在基于构件的软件开发中，逻辑构件模型用功能包描述系统的抽象设计，用接口描述每个服务集合，以及功能之间如何交互以满足用户需求，它作为系统的设计蓝图以保证系统提供适当的功能。物理构件模型用技术设施产品、硬件分布和拓扑结构、以及用于绑定的网络和通信协议描述系统的物理设计，这种架构用于了解系统的性能、吞吐率等许多非功能性属性。 【答案】：B。","topicDesc":"【2010 年题 31】在基于构件的软件开发中，( )用来了解系统的性能、吞吐率等非功能性属性； ","topicType":1,"updateB":"0"}
2022-02-15 10:11:42.390 [XNIO-1 task-1] INFO  traceId[23382f73-ef23-4504-bdce-f93f8edd6877] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:17:04.381 [XNIO-1 task-1] INFO  traceId[c7b32a27-cc71-41c3-a466-1bec3633dbc2] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"分析模式","serialNumber":1},{"correct":false,"option":"设计模式","serialNumber":2},{"correct":true,"option":"架构风格","serialNumber":3},{"correct":false,"option":"架构标准","serialNumber":4}],"queSetId":2,"remark":"【解析】本题主要考查以架构为核心的软件系统开发方法。在该方法中，架构用来激发和调整设计策略，不同的视图用来表达与质量目标有关的信息。架构设计是一个迭代过程，在建立软件架构的初期，选择一个合适的架构风格是首要的，在此基础上，开发人员通过架构模型，可以获得关于软件架构属性的理解，为将来的架构实现与演化过程建立了目标。【答案】：C。","topicDesc":"【2012 年题 15】采用以架构为核心的软件开发方法，在建立软件架构的初期，首要任务是选择一个合适的( )","topicType":1,"updateB":"0"}
2022-02-15 10:17:04.402 [XNIO-1 task-1] INFO  traceId[c7b32a27-cc71-41c3-a466-1bec3633dbc2] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:18:02.978 [XNIO-1 task-1] INFO  traceId[a07f85b6-7bff-4261-bfd2-fbea7af46f21] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"架构需求","serialNumber":1},{"correct":true,"option":"架构属性","serialNumber":2},{"correct":false,"option":"架构优先级","serialNumber":3},{"correct":false,"option":"架构约束","serialNumber":4}],"queSetId":2,"remark":"【解析】本题主要考查以架构为核心的软件系统开发方法。在该方法中，架构用来激发和调整设计策略，不同的视图用来表达与质量目标有关的信息。架构设计是一个迭代过程，在建立软件架构的初期，选择一个合适的架构风格是首要的，在此基础上，开发人员通过架构模型，可以获得关于软件架构属性的理解，为将来的架构实现与演化过程建立了目标。【答案】：B。","topicDesc":"【2012 年题 15】采用以架构为核心的软件开发方法，在建立软件架构的初期，首要任务是选择一个合适的(架构风格 )，在此基础上，开发人员通过架构模型，可以获得关于上( )的理解，为将来的架构实现与演化过程建立了目标","topicType":1,"updateB":"0"}
2022-02-15 10:18:02.984 [XNIO-1 task-1] INFO  traceId[a07f85b6-7bff-4261-bfd2-fbea7af46f21] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:20:42.534 [XNIO-1 task-1] INFO  traceId[1b3fc814-c77d-420f-a355-54b259e62292] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"对于较为复杂的应用问题，适合采用形式化方法进行需求分析","serialNumber":1},{"correct":false,"option":"形式化方法的优势在于能够精确地表述和研究应用问题及其软件实现","serialNumber":2},{"correct":false,"option":"净室软件工程将正确性验证作为发现和排除错误的主要机制","serialNumber":3},{"correct":false,"option":"净室软件工程强调统计质量控制技术，包括对客户软件使用预期的测试","serialNumber":4}],"queSetId":2,"remark":"【【2012 年题 22 解析】软件开发方法是指软件开发过程所遵循的办法和步骤，从不同的角度可以对软件开发方法进行不同的分类。形式化方法是一种具有坚实数学基础的方法，从而允许对系统和开发过程做严格处理和论证，适用于那些系统安全级别要求极高的软件的开发。形式化方法的主要优越性在于它能够数学地表述和研究应用问题及软件实现(B 选项)。但是它要求开发人员具备良好的数学基础。用形式化语言书写的大型应用问题的软件规格说明往往过于细节化，并且难于为用户和软件设计人员所理解。由于这些缺陷，形式化方法在目前的软件开发实践中并未得到普遍应用。净室软件工程(Cleanroom Software Engineering，CSE)是软件开发的一种形式化方法，可以开发较高质量的软件。它使用盒结构规约进行分析和建模，并且将正确性验证作为发现和排除错误的主要机制(C 选项)，使用统计测试来获取认证软件可靠性所需要的信息。CSE 强调在规约和设计上的严格性，还强调统计质量控制技术，包括基于客户对软件的预期使用测试(D 选项)。【答案】：A。","topicDesc":"【2012 年题 22】以下关于软件开发方法的叙述，错误的是( )。","topicType":1,"updateB":"0"}
2022-02-15 10:20:42.553 [XNIO-1 task-1] INFO  traceId[1b3fc814-c77d-420f-a355-54b259e62292] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:22:43.265 [XNIO-1 task-1] INFO  traceId[35f5f3ac-20ee-4e14-8e73-9b150a9e859f] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"在进行结构化分析时，必须使用数据流图和软件结构图这两种模型","serialNumber":1},{"correct":true,"option":"采用面向对象开发方法时，可以使用状态图和活动图对系统的动态行为进行建模","serialNumber":2},{"correct":false,"option":"实体联系图(E-R 图)是在数据库逻辑结构设计时才开始创建的模型","serialNumber":3},{"correct":false,"option":"UML 的活动图与程序流程图的表达能力等价","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 28 解析】【答案】B。ACD 选项说法绝对。","topicDesc":"【2010 年题 28】下列关于不同软件开发方法所使用的模型的描述中，正确的是( )。","topicType":1,"updateB":"0"}
2022-02-15 10:22:43.287 [XNIO-1 task-1] INFO  traceId[35f5f3ac-20ee-4e14-8e73-9b150a9e859f] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:24:46.468 [XNIO-1 task-1] INFO  traceId[3611e8b4-d1db-4cf3-93c0-7eddc4dbcb3c] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"自顶向下过程因为单元测试而比较耗费时间","serialNumber":1},{"correct":false,"option":"自顶向下过程可以更快地发现系统性能方面的问题","serialNumber":2},{"correct":true,"option":"相对于自底向上方法，自顶向下方法可以更快地得到系统的演示原型","serialNumber":3},{"correct":false,"option":"在自顶向下的设计中，如发现了一个错误，通常是因为底层模块没有满足其规格说明(因为高层模块已经被测试过了)","serialNumber":4}],"queSetId":2,"remark":"【2013 年题 25 解析】自顶向下方法的优点是： 1、可为企业或机构的重要决策和任务实现提供信息。 2、支持企业信息系统的整体性规划，并对系统的各子系统的协调和通信提供保证。 3、方法的实践有利于提高企业人员整体观察问题的能力，从而有利于寻找到改进企业组织的途径。自顶向下方法的缺点是： 1、对系统分析和设计人员的要求较高。 2、开发周期长，系统复杂，一般属于一种高成本、大投资的工程。 3、对于大系统而言自上而下的规划对于下层系统的实施往往缺乏约束力。 4、从经济角度来看，很难说自顶向下的做法在经济上是合算的。 【答案】C。","topicDesc":"【2013 年题 25】以下关于自顶向下开发方法的叙述中，正确的是( )。","topicType":1,"updateB":"0"}
2022-02-15 10:24:46.489 [XNIO-1 task-1] INFO  traceId[3611e8b4-d1db-4cf3-93c0-7eddc4dbcb3c] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:27:57.830 [XNIO-1 task-1] INFO  traceId[13a16042-4b83-4cf8-8105-4b328533e1cd] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"模块定义","serialNumber":1},{"correct":false,"option":"消息结构","serialNumber":2},{"correct":false,"option":"接口描述","serialNumber":3},{"correct":true,"option":"值类型","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 28 解析】暂无。 【答案】D。","topicDesc":"【2017 年题 28】OMG 接口定义语言 IDL 文件包含了六种不同的元素，( )是一个 IDL 文件核心的内容，( )将映射为 Java 语言中的包 (package)或 c++语言中的命名空间(Namespace)。","topicType":1,"updateB":"0"}
2022-02-15 10:27:57.852 [XNIO-1 task-1] INFO  traceId[13a16042-4b83-4cf8-8105-4b328533e1cd] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:28:09.160 [XNIO-1 task-1] INFO  traceId[70cbbd0b-5c6a-4a0f-b8f1-0c41060a4360] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"模块定义","serialNumber":1},{"correct":false,"option":"消息结构","serialNumber":2},{"correct":false,"option":"接口描述","serialNumber":3},{"correct":true,"option":"值类型","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 28 解析】暂无。 【答案】D。","topicDesc":"【2017 年题 28】OMG 接口定义语言 IDL 文件包含了六种不同的元素，( )是一个 IDL 文件核心的内容。","topicType":1,"updateB":"0"}
2022-02-15 10:28:09.167 [XNIO-1 task-1] INFO  traceId[70cbbd0b-5c6a-4a0f-b8f1-0c41060a4360] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 10:28:59.073 [XNIO-1 task-1] INFO  traceId[659947af-9c23-4cf8-87ca-945198739813] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"模块定义","serialNumber":1},{"correct":false,"option":"消息结构","serialNumber":2},{"correct":false,"option":"接口描述","serialNumber":3},{"correct":false,"option":"值类型","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 28 解析】暂无。 【答案】A。","topicDesc":"【2017 年题 28】OMG 接口定义语言 IDL 文件包含了六种不同的元素，( )将映射为 Java 语言中的包 (package)或 c++语言中的命名空间(Namespace)。","topicType":1,"updateB":"0"}
2022-02-15 10:28:59.081 [XNIO-1 task-1] INFO  traceId[659947af-9c23-4cf8-87ca-945198739813] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:24:51.319 [XNIO-1 task-1] INFO  traceId[292e879f-2adf-47e9-9827-e520629f88e1] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"用例及用例图","serialNumber":1},{"correct":false,"option":"包图及类图","serialNumber":2},{"correct":false,"option":"剧情及序列图","serialNumber":3},{"correct":false,"option":"组件图及部署图","serialNumber":4}],"queSetId":2,"remark":"【2012 年题 24 解析】在初步的业务需求描述已经形成的前提下，基于 UML 的需求分析过程大致可分为以下步骤：(1)、利用用例及用例图表示需求。从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例图之间的关系，生成用例图。(2)、利用包图和类图表示目标软件系统的总体框架结构。根据领域知识、业务需求描述和既往经验设计目标软件系统的顶层架构；从业务需求描述中提取“关键概念”，形成领域概念模型；从概念模型和用例出发，研究系统中主要的类之间的关系，生成类图。。 【答案】A。","topicDesc":"【2012 年题 24】基于 UML 的需求分析过程的基本步骤为：利用( )表示需求；","topicType":1,"updateB":"0"}
2022-02-15 16:24:51.345 [XNIO-1 task-1] INFO  traceId[292e879f-2adf-47e9-9827-e520629f88e1] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:25:20.465 [XNIO-1 task-1] INFO  traceId[6959c177-051f-4f40-a571-c15a3ca40d18] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"用例及用例图","serialNumber":1},{"correct":true,"option":"包图及类图","serialNumber":2},{"correct":false,"option":"剧情及序列图","serialNumber":3},{"correct":false,"option":"组件图及部署图","serialNumber":4}],"queSetId":2,"remark":"【2012 年题 24 解析】在初步的业务需求描述已经形成的前提下，基于 UML 的需求分析过程大致可分为以下步骤：(1)、利用用例及用例图表示需求。从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例图之间的关系，生成用例图。(2)、利用包图和类图表示目标软件系统的总体框架结构。根据领域知识、业务需求描述和既往经验设计目标软件系统的顶层架构；从业务需求描述中提取“关键概念”，形成领域概念模型；从概念模型和用例出发，研究系统中主要的类之间的关系，生成类图。。 【答案】B。","topicDesc":"【2012 年题 24】基于 UML 的需求分析过程的基本步骤为：利用( )表示目标软件系统的总体架构；","topicType":1,"updateB":"0"}
2022-02-15 16:25:20.471 [XNIO-1 task-1] INFO  traceId[6959c177-051f-4f40-a571-c15a3ca40d18] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:27:05.782 [XNIO-1 task-1] INFO  traceId[0eeb55e6-7f13-4f2d-b828-01905c28f3db] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"问题陈述","serialNumber":1},{"correct":false,"option":"项目范围","serialNumber":2},{"correct":false,"option":"候选方案及其可行性分析","serialNumber":3},{"correct":true,"option":"系统详细设计方案","serialNumber":4}],"queSetId":2,"remark":"【2014 年题 16 解析】作为一份正式文档，系统建议方案至少应该包含以下内容： ①前置部分。包括标题、目录和摘要。摘要部分以 1〜 2 页的篇幅总结整个系统建议方案报告，提供系统方案中的重要事件、地点、任务和原因，以及系统方案是如何实现的等信息。②系统概述。包括系统建议方案报告的目的、对问题的陈述、项目范围和报告内容的叙述性解释。 ③系统研究方法。简要地解释系统建议方案报告中包含的信息是如何得到的，研究工作是如何进行的。 ④候选系统方案及其可行性分析。系统阐述每个候选系统方案，并对每个方案进行可行性评价。⑤建议方案。在对各个候选系统方案进行可行性评价之后，通常会推荐一个解决方案，并且要给出推荐该解决方案的理由。 ⑥结论。简要地描述摘要的内容，再次指出系统开发的目标和所建议的系统方案。同时，需要再次强调项目的必要性和可行性，以及系统建议方案报告的价值。 ⑦附录。系统分析师认为阅读者可能会感兴趣的所有信息，但这些信息对于理解系统建议方案报告的内容来说不是必要的。 【答案】D。","topicDesc":"【2014 年题 16】系统建议方案中不应该包含的内容是( )。","topicType":1,"updateB":"0"}
2022-02-15 16:27:05.806 [XNIO-1 task-1] INFO  traceId[0eeb55e6-7f13-4f2d-b828-01905c28f3db] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:28:31.121 [XNIO-1 task-1] INFO  traceId[42d5502e-3fe2-4256-8f25-3c18e151f2a2] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"结构优化、编译优化和代码优化","serialNumber":1},{"correct":false,"option":"软硬件协同设计、开发过程优化和环境设计优化","serialNumber":2},{"correct":false,"option":"轻量级操作系统、算法优化和仿真实验","serialNumber":3},{"correct":true,"option":"编译优化技术、软硬件协同设计和算法优化","serialNumber":4}],"queSetId":2,"remark":"【2018 年题 9 解析】软件设计层面的功耗控制主要可以从以下方面展开： 1 软硬件协同设计，即软件的设计要与硬件的匹配，考虑硬件因素。 2 编译优化，采用低功耗优化的编译技术。 3 减少系统的持续运行时间，可从算法角度进行优化。 4 用“中断”代替“查询” 5 进行电源的有效管理答案 D。","topicDesc":"【2018 年题 9】嵌入式系统设计一般要考虑低功耗，软件设计也要考虑低功耗设计，软件低功耗设计一般采用（ ）。","topicType":1,"updateB":"0"}
2022-02-15 16:28:31.144 [XNIO-1 task-1] INFO  traceId[42d5502e-3fe2-4256-8f25-3c18e151f2a2] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:29:49.703 [XNIO-1 task-1] INFO  traceId[72041a80-573f-461a-b782-bdd22b1aaf47] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"程序流程图、PAD 图和伪代码","serialNumber":1},{"correct":false,"option":"模块结构图、数据流图和盒图","serialNumber":2},{"correct":true,"option":"模块结构图、层次图和 HIPO 图","serialNumber":3},{"correct":false,"option":"程序流程图、数据流图和层次图","serialNumber":4}],"queSetId":2,"remark":"【2018 年题 23 解析】答案：C。","topicDesc":"【2018 年题 23】软件概要设计包括设计软件的结构、确定系统功能模块及其相互关系，主要采用（ ）描述程序的结构。","topicType":1,"updateB":"0"}
2022-02-15 16:29:49.724 [XNIO-1 task-1] INFO  traceId[72041a80-573f-461a-b782-bdd22b1aaf47] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:32:19.835 [XNIO-1 task-1] INFO  traceId[5114ecf6-8df4-4f6f-a4fd-d1473dd1130c] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"程序流程图（PFD）用于描速系统中每个模块的输入，输出和数据加工","serialNumber":1},{"correct":false,"option":"N-S 图容易表示嵌套关系和层次关系，并具有强烈的结构化特征","serialNumber":2},{"correct":false,"option":"IPO 图的主体是处理过程说明，可以采用流程图、判定树/表等来进行描述","serialNumber":3},{"correct":false,"option":"问题分析图（PAD）包含 5 种基本控制结构，并允许递归使用","serialNumber":4}],"queSetId":2,"remark":"【2012 年题 22 解析】程序流程图(Program How Diagram，PFD)，N-S 图与 PFD 类似，IPO 图是由 IBM 公司发起并逐步完善的一种流程描述工具。用于描述系统中每个模块的输入，输出和数据加工的图是 IPO 图，而非程序流程图。答案：A。","topicDesc":"【2015 年题 22】处理流程设计是系统设计的重要内容。以下关于处理流程设计工具的叙述中，不正确的是（ ）。","topicType":1,"updateB":"0"}
2022-02-15 16:32:19.856 [XNIO-1 task-1] INFO  traceId[5114ecf6-8df4-4f6f-a4fd-d1473dd1130c] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:33:33.255 [XNIO-1 task-1] INFO  traceId[4b4f9637-18a3-4a6a-93e8-8cee0f977ce2] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"顺序、选择和嵌套","serialNumber":1},{"correct":true,"option":"顺序、分支和循环","serialNumber":2},{"correct":false,"option":"分支、并发和循环","serialNumber":3},{"correct":false,"option":"跳转、选择和并发","serialNumber":4}],"queSetId":2,"remark":"【2015 年题 24 解析】结构化程序设计的三种基本控制结构就是：顺序、分支和循环。答案：A。","topicDesc":"【2015 年题 24】结构化程序设计采用自顶向下、逐步求精及模块化的程序设计方法，通过( )三种基本的控制结构可以构造出任何单入口单出口的程序。","topicType":1,"updateB":"0"}
2022-02-15 16:33:33.274 [XNIO-1 task-1] INFO  traceId[4b4f9637-18a3-4a6a-93e8-8cee0f977ce2] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:38:06.281 [XNIO-1 task-1] INFO  traceId[13bed714-7cfe-4c83-95f7-63d5e69154b1] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"数据流模型","serialNumber":1},{"correct":true,"option":"领域概念模型","serialNumber":2},{"correct":false,"option":"功能分解图","serialNumber":3},{"correct":false,"option":"功能需求模型","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 25 解析】面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。。答案：B。","topicDesc":"【2017 年题 25】面向对象的分析模型主要由顶层架构图、用例与用例图和( )构成","topicType":1,"updateB":"0"}
2022-02-15 16:38:06.302 [XNIO-1 task-1] INFO  traceId[13bed714-7cfe-4c83-95f7-63d5e69154b1] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:39:20.060 [XNIO-1 task-1] INFO  traceId[037b8ffa-79b3-434f-bf00-61c7eeca06f5] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"模型试图控制器","serialNumber":1},{"correct":false,"option":"组件图","serialNumber":2},{"correct":true,"option":"包图","serialNumber":3},{"correct":false,"option":"2 层、3 层或 N 层","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 25 解析】面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。。答案：C。","topicDesc":"【2017 年题 25】面向对象的分析模型主要由顶层架构图、用例与用例图和( 领域概念模型)构成,设计模型则包含以( )表示的软件体系机构图","topicType":1,"updateB":"0"}
2022-02-15 16:39:20.081 [XNIO-1 task-1] INFO  traceId[037b8ffa-79b3-434f-bf00-61c7eeca06f5] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:40:07.586 [XNIO-1 task-1] INFO  traceId[c92b8baf-8273-4fa2-b3bc-7535d229ea2e] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"序列图","serialNumber":1},{"correct":false,"option":"协作图","serialNumber":2},{"correct":false,"option":"流程图","serialNumber":3},{"correct":true,"option":"状态图","serialNumber":4}],"queSetId":2,"remark":"【2017 年题 25 解析】面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。。答案：D。","topicDesc":"【2017 年题 25】面向对象的分析模型主要由顶层架构图、用例与用例图和( 领域概念模型)构成,设计模型则包含以(包图 )表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的( )和用以描述流程化处理过程的活动图等。","topicType":1,"updateB":"0"}
2022-02-15 16:40:07.593 [XNIO-1 task-1] INFO  traceId[c92b8baf-8273-4fa2-b3bc-7535d229ea2e] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:43:05.403 [XNIO-1 task-1] INFO  traceId[d73afc50-51d9-46cc-b8bb-a2d499e3a8a8] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"实现视图","serialNumber":1},{"correct":false,"option":"进程视图","serialNumber":2},{"correct":true,"option":"逻辑视图","serialNumber":3},{"correct":false,"option":"部署视图","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 24 解析】在 RUP 中采用“4+1”视图模型来描述软件系统的体系结构。“4+1”视图包括逻辑视图、实现视图、进程视图、部署视图和用例视图。分析人员和测试人员关心的是系统的行为，因此会侧重于用例视图；最终用户关心的是系统的功能，因此会侧重于逻辑视图；程序员关心的是系统的配置、装配等问题，因此会侧重于实现视图；系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，因此会侧重于进程视图；系统工程师关心的足系统的发布、安装、拓扑结构等问题，因此会侧重于部署视图。。答案：C。","topicDesc":"【2010 年题 24】在 RUP 中采用“4+1”视图模型来描述软件系统的体系结构。在该模型中，最终用户侧重于( )","topicType":1,"updateB":"0"}
2022-02-15 16:43:05.424 [XNIO-1 task-1] INFO  traceId[d73afc50-51d9-46cc-b8bb-a2d499e3a8a8] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:48:19.174 [XNIO-1 task-1] INFO  traceId[40a48183-aff6-4276-a583-d45ad5b6c073] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"逻辑","serialNumber":1},{"correct":false,"option":"过程","serialNumber":2},{"correct":false,"option":"开发","serialNumber":3},{"correct":false,"option":"物理","serialNumber":4}],"queSetId":2,"remark":"【2014 年题 31 解析】“4+1”视图模型从五个不同的视角来描述软件架构，每个视图只关心系统的一个侧面，五个视图结合在一起才能反映软件架构的全部内容。(1)逻辑视图。逻辑视图主要支持系统的功能需求，即系统提供给最终用户的服务。(2)开发视图。开发视图也称为模块视图，在 UML 中被称为实现视图，它主要侧重于软件模块的组织和管理。开发视图要考虑软件内部的需求。(3)进程视图。进程视图侧重于系统的运行特性，主要关注一些非功能性需求，例如，系统的性能和可用性等。进程视图强调并发性、分布性、系统集成性和容错能力。(4)物理视图。物理视图在 UML 中被称为部署视图，它主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结构、系统安装和通信等问题。(5)场景。场景可以看作是那些重要系统活动的抽象，它使四个视图有机联系起来，从某种意义上说场景是最重要的需求抽象。场景视图对应 UML 中的用例视图。。答案：A。","topicDesc":"【2014年题31】“4+1”视图主要用于描述系统逻辑架构，最早由 Philippe Kruchten于1995年提出。其中( )视图用于描述对象模型，并说明系统应该为用户提供哪些服务。","topicType":1,"updateB":"0"}
2022-02-15 16:48:19.195 [XNIO-1 task-1] INFO  traceId[40a48183-aff6-4276-a583-d45ad5b6c073] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:49:49.212 [XNIO-1 task-1] INFO  traceId[9537a737-358e-433b-9576-eb5e44b10d61] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"对象图","serialNumber":1},{"correct":false,"option":"活动图","serialNumber":2},{"correct":false,"option":"状态图","serialNumber":3},{"correct":true,"option":"类图","serialNumber":4}],"queSetId":2,"remark":"【2014 年题 31 解析】下面是题目选项中几种 UML 图的解释，从中可以了解题目所描述的，是哪一种 UML 图。(1)对象图(object diagram)。对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。和类图一样，这些图给出系统的静态设计视图或静态进程视图，但它们是从真实案例或原型案例的角度建立的。(2)活动图(activity diagram)。活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。活动图专注于系统的动态视图。它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。(3)状态图(state diagram)。状态图描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。(4)类图(class diagram)。类图描述一组类、接口、协作和它们之间的关系。在 OO 系统的建模中，最常见的图就是类图。类图给出了系统的静态设计视图，活动类的类图给出了系统的静态进程视图。。答案：D。","topicDesc":"【2014年题31】“4+1”视图主要用于描述系统逻辑架构，最早由 Philippe Kruchten于1995年提出。其中当采用面向对象的设计方法描述对象模型时，通常使用( )表达类的内部属性和行为。","topicType":1,"updateB":"0"}
2022-02-15 16:49:49.231 [XNIO-1 task-1] INFO  traceId[9537a737-358e-433b-9576-eb5e44b10d61] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:50:40.037 [XNIO-1 task-1] INFO  traceId[445e3042-77eb-4fd0-99aa-dc6491229de0] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"对象图","serialNumber":1},{"correct":true,"option":"活动图","serialNumber":2},{"correct":false,"option":"状态图","serialNumber":3},{"correct":false,"option":"类图","serialNumber":4}],"queSetId":2,"remark":"【2014 年题 31 解析】下面是题目选项中几种 UML 图的解释，从中可以了解题目所描述的，是哪一种 UML 图。(1)对象图(object diagram)。对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。和类图一样，这些图给出系统的静态设计视图或静态进程视图，但它们是从真实案例或原型案例的角度建立的。(2)活动图(activity diagram)。活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。活动图专注于系统的动态视图。它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。(3)状态图(state diagram)。状态图描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。(4)类图(class diagram)。类图描述一组类、接口、协作和它们之间的关系。在 OO 系统的建模中，最常见的图就是类图。类图给出了系统的静态设计视图，活动类的类图给出了系统的静态进程视图。。答案：B。","topicDesc":"【2014年题31】“4+1”视图主要用于描述系统逻辑架构，最早由 Philippe Kruchten于1995年提出。其中当采用面向对象的设计方法描述对象模型时，通常使用(XX )表达类的内部属性和行为，以及类集合之间的交互关系；采用(? )定义对象的内部行为。","topicType":1,"updateB":"0"}
2022-02-15 16:50:40.055 [XNIO-1 task-1] INFO  traceId[445e3042-77eb-4fd0-99aa-dc6491229de0] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:53:59.415 [XNIO-1 task-1] INFO  traceId[b38f2894-27db-4028-9217-5b03f38bdb57] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":true,"option":"尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程","serialNumber":1},{"correct":false,"option":"创建一个新的抽象类 C，作为两个具体类的超类，将 A 和 B 共同的行为移动到 C中，从而解决 A 和 B 行为不完全一致的问题","serialNumber":2},{"correct":false,"option":"将 B 到 A 的继承关系改成组合关系","serialNumber":3},{"correct":false,"option":"区分是“Is-a”还是“Has-a”。如果是 Is-a，可以使用继承关系，如果是 Has-a，应该改成组合或聚合关系","serialNumber":4}],"queSetId":2,"remark":"里氏替换原则是面向对象设计原则之一，由 Barbara liskov 提出，其基本思想是，一个软件实体如果使用的是一个基类对象，那么一定适用于其子类对象，而且觉察不出基类对象和子类对象的区别，即把基类都替换成它的子类，程序的行为没有变化。反过来则不一定成立，如果一个软件实体使用的是一个子类对象，那么它不一定适用于基类对象。在运用里氏替换原则时，尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程。由于子类继承基类并实现其中的方法，程序运行时，子类对象可以替换基类对象，如果需要对类的行为进行修改，可以扩展基类，增加新的于类，而无需修改调用该基类对象的代码。。答案 A","topicDesc":"【2012 年题 20】对于违反里氏替换原则的两个类 A 和 B，可以来用的候选解决方案中，正确的是( )。","topicType":1,"updateB":"0"}
2022-02-15 16:53:59.440 [XNIO-1 task-1] INFO  traceId[b38f2894-27db-4028-9217-5b03f38bdb57] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
2022-02-15 16:57:20.517 [XNIO-1 task-1] INFO  traceId[985cc5ac-8bbd-424d-b2b8-844848124b78] com.example.demo.controller.TopicManageController:33 - 提交题目信息：{"createBy":"0","errorNum":1,"img":"","optionItem":[{"correct":false,"option":"数据类型检查","serialNumber":1},{"correct":false,"option":"自检位","serialNumber":2},{"correct":true,"option":"域检查","serialNumber":3},{"correct":false,"option":"格式检查","serialNumber":4}],"queSetId":2,"remark":"【2010 年题 35 解析】系统输入设计中，通常通过内部控制的方式验证输入数据的有效性。数据类型检查确保输入了正确的数据类型；自检位用于对主关键字进行基于校验位的检查；域检查用于验证数据是否位于合法的取值范围；格式检查按照已知的数据格式对照检查输入数据的格式。答案 C","topicDesc":"【2010 年题 35】系统输入设计中，采用内部控制方式以确保输入系统数据的有效性，( )用于验证数据是否位于合法的取值范围。","topicType":1,"updateB":"0"}
2022-02-15 16:57:20.537 [XNIO-1 task-1] INFO  traceId[985cc5ac-8bbd-424d-b2b8-844848124b78] com.example.demo.Interceptor.LogInterceptor:45 - 调用结束后删除...
